[{"categories":null,"content":" Motivation IBM recently published a paper that carried out the Trotterized time evolution of a transverse-field Ising model Hamiltonian \\(H = -J \\sum_{\u003ci,j\u003e}Z_{i}Z_{j} + h \\sum_{i}X_{i}\\) on 127 qubits. The quantum circuit used for time evolution consisted of \"up to 60 layers of two-qubit gates, a total of 2880 CNOT gates\" [1]. This is a significant experiment due to the relatively low quality of CNOT gates across all currently available quantum computing platforms. The number and layers of CNOT gates involved generally can lead to meaningless results due to noise. A brute-force classical simulation of such a quantum circuit is definitely out of reach for even the most powerful supercomputers. The wording of their title, suggesting that their experiment demonstrates quantum utility (a weaker version of quantum advantage), received mixed reviews within the Quantum Computing community on Twitter. However, some positive results emerged from the discussions between proponents of this paper and others. For instance, Sels and colleagues [2] demonstrated a method to exploit the heavy-hexagon topology of IBM's superconducting quantum chip to speed up classical simulation of the quantum circuit in IBM's paper with belief propagation tensor networks. This, although contradicting IBM's claim of demonstrating quantum utility, helps extend our understanding of classical simulation of quantum circuits. Unfortunately, an in-depth analysis of this topic is beyond the scope of this blog. Interested readers are encouraged to consult the reference below and investigate further on their own. Conversely, IBM clarifies that the essence of this paper is not quantum utility but two other crucial aspects. First, it demonstrates \"advances in the coherence and calibration of a superconducting processor at this scale\", with 127 qubits [1]. More importantly, it showcases \"the ability to characterize and controllably manipulate noise across such a large device\" [1], which will be the primary focus of this post. This post will proceed as follows: First, I will discuss the importance of Quantum Error Mitigation by examining the effect of noise on quantum computers and why Quantum Error Correction is not a viable solution at present. Then, I will delve into one of the Quantum Error Mitigation techniques used in IBM's paper - Zero Noise Extrapolation. Finally, I will conclude with how IBM improved upon the basic Zero Noise Extrapolation with the Pauli-Lindblad noise model to achieve promising experimental results on 127 qubits. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:1:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Achilles Heel of Quantum Computer: Noise One of the most formidable challenges faced by quantum computers is noise. It's widely recognized that quantum algorithms can outperform their classical counterparts in solving a few critical problems. For instance, our daily communication, web browsing, and bank transactions are safeguarded by public-key encryption schemes such as RSA and Diffie-Hellman schemes. These methods hinge on the difficulty of period finding [3]. Shor's algorithm solves the period finding problem exponentially faster than classical methods. However, noise renders the results of Shor's algorithm useless on real quantum computers. Since Shor's algorithm was used to factor 15 on an NMR quantum computer in 2012 [4], only one other experiment has successfully pushed this limit to 21 using Shor's algorithm [5]. Noise has made it impossible to scale Shor's algorithm further. Of course, solutions have been proposed to tackle the noise problem on quantum computers. Quantum Error Correction—an algorithm that shields information from noise and decoherence—has been considered. This algorithm accomplishes its goal using Quantum Error Correction codes, which encode one qubit's worth of information onto multiple, physically separated qubits. As noise and decoherence result from undesirable physical interactions, information encoded onto physically separated qubits is safeguarded from noise. This protection is based on the fact that our world predominantly supports local physical interactions. To interfere with information that is physically separated, one would need non-local interaction, which is typically unlikely. However, a significant challenge with implementing Quantum Error Correction codes is posed by the threshold theorem. This theorem proposes that \"a quantum computer with a physical error rate below a certain threshold can reduce the logical error rate to arbitrarily low levels\" through the application of Quantum Error Correction schemes [6]. Today's most advanced physical qubits can barely achieve parity in terms of logical error rate when implementing a Quantum Error Correction code as compared to a basic repetition code [7]. Consequently, with current engineering techniques, Quantum Error Correction cannot eliminate the noise in quantum computers to arbitrary level. Given the inherent noise accompanying all quantum computer operations and the restrictions on the number of a physical quantum computer's qubits, we find ourselves in the Noisy Intermediate Scale Quantum Era, a term coined by John Preskill [8]. Various methods have been proposed to enhance the usability of quantum computers in the face of noise. These methods, collectively known as Quantum Error Mitigation methods, each focus on a specific type of noise. With a particular type of noise in mind, quantum circuits are modified to amplify or cancel the effect the noise has on their results, and post-processing of results is executed on quantum circuit outputs to mitigate the noise's impact on these results. Notable Quantum Error Mitigation techniques include Dynamical Decoupling, Measurement Mitigation, Pauli Twirling, and Zero Noise Extrapolation. The combined application of these techniques made it possible to obtain sensible quantum dynamics simulation results in IBM's paper [1]. The remainder of this blog will be dedicated to explaining Zero Noise Extrapolation, given its straightforward nature and its simplistic assumptions about the underlying noise model of a quantum computer. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:2:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Zero Noise Extrapolation Zero Noise Extrapolation refers to an \"algorithmic scheme(s) that reduce the noise-induced bias in the expectation value by post-processing outputs from an ensemble of circuit runs, using circuits at the same noise level as the original unmitigated circuit or above\" [9]. This technique was initially introduced by Li et al [11] and Temme et al [12] and later popularized by Kandala et al [10] to perform the variational optimization of molecular Hamiltonian of Hydrogen and Lithium hydride. One notable feature of Zero Noise Extrapolation is that it meets the requirement for a \"reliable error mitigation method\" as proposed by Cai et al [9]. Specifically, Zero Noise Extrapolation \"requires few assumptions (or no assumptions) about the final state prepared by the computation\" [9]. Additionally, it places a simple constraint on the noise model and the effect ZNE could mitigate. Hence, Zero Noise Extrapolation stands as a broadly applicable and straightforward-to-implement technique in Quantum Error Mitigation. To comprehend the simplified noise model and its implication on how it influences the expectation value of an operator for the state prepared by a quantum circuit, we need to introduce a few notations. First, denote locations marked by indices \\(i\\), ranging from \\(0\\) to \\(n\\), in a quantum circuit where independent Pauli errors could occur. At each location \\(i\\), the probability of a Pauli error occurring is \\(p_{i}\\). The sum of all probabilities is \\(\\lambda \\equiv \\sum_{i=0}^{n}p_i\\). This can be understood as a noise parameter characterizing how noisy the circuit is. When \\(n\\) is large and \\(\\lambda\\) is moderately sized, Le Cam's inequality suggests that the probability of \\(k\\) errors occurring in a noisy circuit is \\(P_k \\approx e^{-\\lambda}\\lambda^{k}/k!\\) [11], i.e., it is approximated by a Poisson distribution. We then model the erroneous expectation value, \\(\\left\\langle O_\\lambda\\right\\rangle\\) as the weighted sum of operator expectation values with \\(k\\) number of errors occurring during the quantum circuit, \\(\\left\\langle O_{|\\mathbb{L}|=k}\\right\\rangle\\). Specifically, \\( \\left\\langle O_\\lambda\\right\\rangle=\\sum_{k=0}^{\\infty} P_k\\left\\langle O_{|\\mathbb{L}|=k}\\right\\rangle=e^{-\\lambda} \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k !}\\left\\langle O_{|\\mathbb{L}|=k}\\right\\rangle \\). By focusing on the noise parameter \\( \\lambda \\), we observe that the expectation value of the operator follows an exponential decay. Methods like pulse-stretching or unitary-folding [10] could be employed to manually increase the noise level, \\(\\lambda\\), and obtain a noisier expectation value for the operator \\( \\hat{O} \\). After obtaining a set of \\( \\hat{O_{\\lambda}} \\), we could use an exponential fitting to achieve the noiseless estimation of \\( \\hat{O} \\).\" It's remarkable that such a straightforward technique can eliminate the effect of noise from a simple noise model on quantum circuit results. However, it's crucial not to overlook the costs and constraints associated with this technique. Firstly, we are performing an exponential extrapolation, so the accuracy of \\(\\left \\langle O_{\\lambda} \\right \\rangle\\) for each \\(\\lambda\\) needs to be precise, necessitating a small variance. The variance of the estimation of \\(\\left \\langle O_{\\lambda} \\right \\rangle\\) is essentially an expectation value over the \\(N_{sample}\\) of quantum circuit evaluations. This requires large number of sampling points which naturally leads to increased experimental time. Secondly, another challenge arises. Zero Noise Extrapolation essentially requires the noise model affecting the device to remain constant, and the only one who can adjust the noise level is the experimenter. This requirement is suggested to be violated in relation to a physical phenomenon known as Two-Level Defect. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:3:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Two level Defect The Josephson Junction in the superconducting transmon requires an amorphous \\( AlO_x\\) layer between the aluminium electrodes. At low temperatures, Two-Level Defects form in this amorphous layer. These defects can include tunneling atoms, dangling bonds, and trapped charges. As a result, it's proposed that the coupling of Two-Level Defects and qubits induces noise parameter fluctuations on an hourly scale [1]. In IBM's paper, they demonstrated such correlation between the coupling of Two-Level Defects with qubits and device fluctuation [1]. In Figure S4 (b) and (c) of the supplementary information from IBM's Paper [1], a clear drop in the single qubit \\(X\\) operator's expectation value is observed around the \\(99\\) to \\(103\\) hour mark during the experiment. Around the same time, the \\(T_{1}\\) time for the same qubit is observed to fluctuate, indicating a variation in the underlying noise model. This inference is further supported by the extrapolation of the expectation value of a single qubit X operator on a simulatable quantum circuit. When the data points observed during the fluctuation period are discarded, the extrapolation results align well with the ideal circuit simulation results performed on a classical computer, as reported in Figure S4 (d), (e), (f) of IBM's paper [1]. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:3:1","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Pauli-Lindblad Noise Model While the previous method successfully mitigates the effect of fluctuating noise parameters, it has a significant drawback. It requires discarding experimental data, which implies an algorithmic overhead. In larger or more unstable devices, this could eliminate the quantum algorithm's speed advantage. To address this problem, we recognize that the essence of Zero Noise Extrapolation is to amplify the noise level to a desired amount and perform extrapolation. Device quality fluctuation will cause the underlying noise parameter to change from \\(\\lambda\\) to \\(\\alpha \\lambda\\) with \\(\\alpha \u003e 1\\). When we naively amplify the noise with a target of \\(2 \\lambda\\), we end up reaching \\(2 \\alpha \\lambda\\), hence misplacing the data point on the x-axis for extrapolation. To alleviate this without discarding experimental results, a solution is to efficiently characterize the device's noise parameter and then amplify accordingly. In IBM's paper, they employ the Pauli-Lindblad Noise Model [1]. The Pauli-Lindblad Noise model is a \"noise channel \\(\\Lambda\\) that arises from a sparse set of local interactions by a Lindblad generator,\" which yields \\(\\mathcal{L}(\\rho)=\\sum_{k \\in \\mathcal{K}} \\lambda_k\\left(P_k \\rho P_k^{\\dagger}-\\rho\\right)\\) [15]. Note that \\(\\mathcal{K}\\) is a \\(poly(n)\\)-sized subset of \\(4^n\\) Pauli operators on \\(n\\) qubits. You only need to consider a polynomial subset of all possible Pauli operators because of the topology of IBM's quantum computer. Weight two Pauli operators on non-neighboring qubits and higher weight Pauli operators will have no support. Their corresponding noise parameters will be zero. The noise channel is then modeled as \\(\\Lambda(\\rho)=\\exp \\mathcal{L}\\). It can be computed as \\(\\Lambda(\\rho)=\\underset{k \\in \\mathcal{K}}{\\bigcirc}\\left(w_k \\cdot+\\left(1-w_k\\right) P_k \\cdot P_k^{\\dagger}\\right) \\rho\\) where \\(w_k=2^{-1}\\left(1+\\mathrm{e}^{-2 \\lambda_k}\\right)\\)[15]. To characterize the noise parameters \\(\\lambda_{b}\\), we measure \\(f_b\\), the fidelity of Pauli operators \\(P_b\\) with increasing layers of two-qubit gates. Since \\(f_{b} = \\frac{1}{2^{n}}Tr(P_{b}^{\\dagger} \\Lambda(P_{b})\\), we expect \\(log(f_{b}) \\propto \\lambda_{b} * d\\) with \\(d\\) being the number of two-qubit gate layers. Since the supported Pauli operators have a \\(poly(n)\\) number, we can efficiently characterize them. To amplify the noise, experimentalists can manually insert Pauli operators on the two-qubit gate layer of the quantum circuit to mimic the noise modeled in the Pauli-Lindblad noise model. A schematic sense of such amplification can be obtained by examining Fig 1 (d) of IBM's paper [1]. IBM's team compared the extrapolated result using such scheme to classical simulation result and confirmed the correctness of this method. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:4:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Conclusion Quantum error mitigation is fascinating in the sense that, by presenting a physically motivated and reasonable noise model and probing the experimental platform to parameterize it, we can obtain results from non-error corrected circuits. However, it remains unclear to me whether the overhead of noise model probing will be scalable. In other words, will such a technique maintain its effectiveness when applied to industrial applications involving thousands of qubits? Regardless, a successful quantum error mitigation experiment does indicate the validity and accuracy of the target noise model's efficient characterization. In this regard, quantum error mitigation experiments serve as a touchstone for understanding the noise in current NISQ devices. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:5:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Disclaimer I have also done some work in quantum error mitigation. I found the idea of using quantum error mitigation results to verify the noise model occurred in the actual device interesting. This blog is written with love using Emacs and Org Mode. ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:6:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Reference Evidence for the utility of quantum computing before fault tolerance Efficient tensor network simulation of IBM's kicked Ising experiment Scot Aaronson's Lecture notes Experimental realization of Shor's quantum factoring algorithm using nuclear magnetic resonance Experimental realisation of Shor's quantum factoring algorithm using qubit recycling Threshold Theorem Wikipedia Suppressing quantum errors by scaling a surface code logical qubit Quantum Computing in the NISQ era and beyond Quantum Error Mitigation Error mitigation extends the computational reach of a noisy quantum processor Le Cam's Inequality and Poisson Approximations Efficient Variational Quantum Simulator Incorporating Active Error Minimization Error Mitigation for Short-Depth Quantum Circuits Towards understanding two-level-systems in amorphous solids – Insights from quantum circuits Probabilistic error cancellation with sparse Pauli–Lindblad models on noisy quantum processors ","date":"2023-07-08","objectID":"/posts/ibmquantumutil/:7:0","tags":null,"title":"Quantum Error Mitigation","uri":"/posts/ibmquantumutil/"},{"categories":null,"content":" Motivation In my ongoing project on ZX Calculus, I found myself needing an elegant and efficient way to handle objects of specific types and perform operations on their values. Enter Algebraic Data Types (ADTs) - a powerful concept from functional programming. ADTs, coupled with pattern matching, provide a solution that is not only efficient but also expressive, allowing for cleaner, more readable code when dealing with complex data structures. ","date":"2023-07-04","objectID":"/posts/adt/:1:0","tags":null,"title":"Algebraic Data Type","uri":"/posts/adt/"},{"categories":null,"content":" Algebraic Data Types Most programming languages provide types to represent primitive data. For instance, digit numbers are typically represented in Int, and alphabets in char. However, these data types alone might not always convey significant meaning. It's through their composition that we can represent more complex concepts. This is where Algebraic Data Types, first introduced in functional programming, come into play. An Algebraic Data Type (ADT) is a type formulated by composing other types. The algebra in its name encapsulates the operations you may execute on these composed types. You can perform addition on types to create a Sum Type. As an example, in Julia we can define: @enum Shape Circle=1 Rectangle=2 Square=3 RightTriangle=4 This is a sum type because the total number of possible instances of the ADT Shape is the sum of its variants, i.e., Circle, Rectangle, etc. You can also perform multiplication on types to form a Product Type. struct Rectangle length::Int32 width::Int32 end This is a product type because the total number of potential instances of Rectangle is the product of the possible values for length and width. Consequently, you can further compose Sum Types and Product Types to create more intricate Algebraic Data Types. Here is an example of defining a Product Type using Expronicon.jl: using Expronicon.ADT: @adt @adt public Shape begin struct Circle radius::Float32 end struct Rectangle length::Int32 width::Int32 end struct Square side::Int32 end struct RightTriangle side1::Int32 side2::Int32 end end Note the usage of the keyword public; this implies we can use Circle instead of Shape.Circle, making our code more readable and easier to manage. ","date":"2023-07-04","objectID":"/posts/adt/:2:0","tags":null,"title":"Algebraic Data Type","uri":"/posts/adt/"},{"categories":null,"content":" Pattern Matching While representing complex concepts through grouped data is beneficial, manipulating this data is equally critical. The first step to handling data is through extraction, which is achieved by destructuring an Algebraic Data Type. This can be generalized into the concept of pattern matching, defined as 'the act of examining a given sequence of tokens for the presence of the constituents of some pattern' [1]​. A comprehensive list of pattern matching rules can be found in MlStyle.jl's documentation. For the sake of brevity and relevance, I'll provide examples of pattern matching using the ADT defined with Expronicon and the pattern matching feature provided by MLStyle.jl. This choice was made because the ADT in MLStyle.jl supports generic types, so it won't be type stable. For performance reasons, I'll use the ADT from Expronicon. Both packages interact well. function enlarge_shape(s::Shape) @match s begin Circle(r) =\u003e Circle(2r) Rectangle(l,w) =\u003e Rectangle(2l,3w) Square(s) =\u003e Square(s^2) RightTriangle(a,b) \u0026\u0026 if =\u003e RightTriangle(2a,2*b) end end This code accepts an instance of the Algebraic Data Type Shape and enlarges the figure according to the specific type of each passed instance. ","date":"2023-07-04","objectID":"/posts/adt/:3:0","tags":null,"title":"Algebraic Data Type","uri":"/posts/adt/"},{"categories":null,"content":" Performance Analysis Roger, author of Expronicon.jl, has made a comparison between using ADT and naive isa : ternary operator. It has clear performance gain. For the sake of time, I will not try to reproduce them here. ","date":"2023-07-04","objectID":"/posts/adt/:4:0","tags":null,"title":"Algebraic Data Type","uri":"/posts/adt/"},{"categories":null,"content":" Disclaimer This post has been lovingly crafted using Org Babel, a literal programming support application in Emacs. ","date":"2023-07-04","objectID":"/posts/adt/:5:0","tags":null,"title":"Algebraic Data Type","uri":"/posts/adt/"},{"categories":null,"content":" References What's the point of having Algebraic Data Types? Introduction to ADT MLStyle.jl Expronicon.jl ","date":"2023-07-04","objectID":"/posts/adt/:6:0","tags":null,"title":"Algebraic Data Type","uri":"/posts/adt/"},{"categories":null,"content":" Motivation Last time, I went over the basics of Algebraic Data Types. In this short post, I want to explore more details and fundamental reasons why they exist. ","date":"2023-07-04","objectID":"/posts/adt2/:1:0","tags":null,"title":"Algebraic Data Type Again","uri":"/posts/adt2/"},{"categories":null,"content":" Compiler perspective This relates to multi-dispatch of a function. If there's no algebraic data type or something similar, the compiler will not be able to iterate through all possible variants of a data type. Hence, it will not be able to perform checking to see if the program has bugs at compile time. Hence the saying \"if it compiles, it runs\" ","date":"2023-07-04","objectID":"/posts/adt2/:2:0","tags":null,"title":"Algebraic Data Type Again","uri":"/posts/adt2/"},{"categories":null,"content":" Functional programming perspective Defining ADT allows for machine creatable types in general. It's an important property for meta programming. Without this feature, machine will only be able to represent what we initially set it to represent. I.e the types that we create before hand. Which will in evitably be finite and thus limit the possibilities to which the program can achieve. ","date":"2023-07-04","objectID":"/posts/adt2/:3:0","tags":null,"title":"Algebraic Data Type Again","uri":"/posts/adt2/"},{"categories":null,"content":" Reference https://stackoverflow.com/q/31759736 https://softwareengineering.stackexchange.com/questions/287461/what-problem-do-algebraic-data-types-solve https://en.wikipedia.org/wiki/Expression_problem ","date":"2023-07-04","objectID":"/posts/adt2/:4:0","tags":null,"title":"Algebraic Data Type Again","uri":"/posts/adt2/"},{"categories":null,"content":"Purpose In this blog, I have collected some tutorials that I found useful while learning Julia. I will also provide a tool-chain that I like to use while coding in Julia. I hope this will speed up your process of learning Julia. Operating System This is not intended to be a cynical view or criticism against Windows users. However, it’s worth considering the benefits of using Linux or macOS for your programming needs, especially when working with Julia. These platforms foster a more seamless knowledge transfer between new and experienced Julia users, and you’ll likely find a wealth of resources and solutions to your programming challenges. Switching to Linux or macOS can enhance your productivity and provide a more robust environment for programming in general. Julia Installation Sometimes it’s necessary to have multiple versions of Julia on your machine. For example, you might need to test a package whose dependency relies on an earlier version of Julia. A good tool for managing your Julia versions is Juliaup. ","date":"2023-06-07","objectID":"/posts/juliabeginner/:0:0","tags":["Julia"],"title":"Juliabeginner","uri":"/posts/juliabeginner/"},{"categories":null,"content":"Caveats If you found yourself unable to access Juliaup server for some mysterious reasons. Try to use the Tuna mirror by running export JULIAUP_SERVER=https://mirrors.tuna.tsinghua.edu.cn/julia-releases before installing Juliaup. Package Development As I was taught and proven by my own experience, the best way to learn Julia is by writing something. To organize the code you write, you should put it into a package. During the process, I found using PkgTemplates.jl helpful in terms of creating a structured repository. I also found using Revise.jl helpful when you are in need of constant testing and code revisions. A concise introduction to these two packages is provided on the Coding Club page, thanks to Prof. Jin-Guo Liu. Editor A good editor can make your development process much more enjoyable. Personally, I prefer using Doom Emacs with Julia-Snail. However, Emacs comes with a very steep learning curve. Therefore, I would recommend beginners to use VSCode. However, don’t forget to map your keys to Vim’s. It helps. Tutorials Introduction to Julia | Jose Storopoli | JuliaCon 2022 HKUST(GZ) First Coding Club Julia Tutorial Where to find resources Package searching ","date":"2023-06-07","objectID":"/posts/juliabeginner/:1:0","tags":["Julia"],"title":"Juliabeginner","uri":"/posts/juliabeginner/"},{"categories":null,"content":"Repos to Hackathon Projects IBM Spring Challenge 2022 IBM Spring Challenge 2021 ","date":"2022-08-09","objectID":"/hackathons/:0:0","tags":null,"title":"Hackathons","uri":"/hackathons/"},{"categories":null,"content":"List of Online Course and Lecture Notes ","date":"2022-08-08","objectID":"/resources/:0:0","tags":null,"title":"Resources","uri":"/resources/"},{"categories":null,"content":"Physics David Tong lecture notes are awesome for theoretical physics self-study. ","date":"2022-08-08","objectID":"/resources/:1:0","tags":null,"title":"Resources","uri":"/resources/"},{"categories":null,"content":"Computer Science Missing Semester is great for applying programming knowledge in real life. Introductory C Programming Specialization is great for learning / reviewing C. List of Yt Channels Mike Zamansky taught me a lot about using Emacs. Distrotube is a great place to learn about tiling window manager. Ali Abdaal has a lot of great tips on learning and managing your life. List of interesting blogs CS DIY Wiki is a nice guide for self-learning Computer Science Peter Bloem had a great post on SVD John Baez’s blog gives good advices for physics and math students and teaches fun stuff! Yufei Zhao ","date":"2022-08-08","objectID":"/resources/:2:0","tags":null,"title":"Resources","uri":"/resources/"},{"categories":null,"content":"Greetings! Hello, my name is Yusheng Zhao. I come from Shanghai, China. Research Interests I am mainly interested in Quantum Computation. More concretely in the fields of Quantum Simulation Quantum Error Correction and Mitigation Quantum Optimal Pulse Control Quantum Software development Background I received my Master’s degree in Physics from Stony Brook University under the supervision of Prof. Tzu-chieh Wei. I received my B.A in Physics and Computer Science from New York University Hackathon Experiences I enjoy attending Hackathons. I have competed in the following ones. iQuHACK 2021 Hybrid-Division Winner IBM Quantum Challenge Fall 2021 Rank 9 CCF “Compass Cup” Third Prize Winner QHack 2021 QML Challenges Peripherals Confucious once said that “If a workman wishes to do a good job, he must first sharpen his tools.” I try to use the best ergonomic keyboards and mice. Hopefully they will prolong my career as a programmer. I am currently using an Ergodox-EZ keyboard with Logitech MX Ergo. I have used HHKB previously until my wrist starts to hurt due to the small size of that keyboard forcing me to an awkward poise. Misc I have a wide variety of interests. They include Linux ricing, jogging (PR: 10k at 5:21), swimming, tennis, and Water Rowing. I used to enjoy ricing my Emacs configuration. Currently, I found Doom Emacs satisfying all my needs. I use Xmonad to manage my windows on my Linux workstation. ","date":"2022-08-05","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":" Statement Remember one of the problems in HW denoted as `3n+1` problem. It has another name as [Collatz Conjecture] ","date":"0001-01-01","objectID":"/posts/collatz/:1:0","tags":null,"title":"","uri":"/posts/collatz/"},{"categories":null,"content":" What is the importance of random circuit sampling Quantum supermacy, the quest for looking for a task that can be proven to be prohibitively hard for classical computer but easy for quantum computer, is the goal for many quantum information scientist. To prove quantum supermacy, there are in general two categories of proposals. The first category is ones that can be proven to be hard complexity wise but challenging experiment-wise (need to look at Aaronson paper). The prime example being Bonson Sampling task proposed by Aaronson. The other type being the ones which is not weaker in the complexity sense but easier to implement experimentally. The prime example of this category of experiments is Random Circuit Sampling. Random circuit sampling is the task of sampling for the probability distribution of computational basis state from a parameterized circuit. Such family of parameterized circuits will have a certain structure. For example, they can be layered circuit with two qubit gates on pairs of qubits on the odd layers and single qubit gates on the even layers. They are parameterized in the sense that the two qubit and single qubit gates are paramterized by some variables. For example, single qubit gate can be $Rx(\\theta)$ where $\\theta$ is the parameterizing variable. In the paper by Bouland et. al, it is proven that such RCS protocal is theoretically well based to prove. ","date":"0001-01-01","objectID":"/posts/testnoiseandrcs/:1:0","tags":null,"title":"Noise on Random Circuit Sampling","uri":"/posts/testnoiseandrcs/"},{"categories":null,"content":" What is counter intuitive about result of noisy simulation? Little non-unital noise dominates the effect of pushing circuit result to concentraional. ","date":"0001-01-01","objectID":"/posts/testnoiseandrcs/:2:0","tags":null,"title":"Noise on Random Circuit Sampling","uri":"/posts/testnoiseandrcs/"},{"categories":null,"content":" References [Anchor](https://arxiv.org/abs/2306.16659) [Establish RCS as theoretically sound method](https://www.nature.com/articles/s41567-018-0318-2) ","date":"0001-01-01","objectID":"/posts/testnoiseandrcs/:3:0","tags":null,"title":"Noise on Random Circuit Sampling","uri":"/posts/testnoiseandrcs/"}]